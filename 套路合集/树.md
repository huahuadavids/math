# 树算法

## 前缀树
- 前缀树又叫做Trie，字典树、单词查找树或键树，来源于英文单词retrieval(检索)
- 前缀树是一种特殊的多叉树，核心思想是空间换时间。
- 用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

它有3个基本性质
- 根节点不包含字符，除根节点外每一个节点都只包含一个字符。
- 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
- 每个节点的所有子节点包含的字符都不相同
- 一个节点的子节点，最多26个节点(26个英文字母)
- Trie树的平均高度h为len，所以Trie树的查询复杂度为O（h）=O（len）

```javascript
class TrieNode {
    constructor(w) {
        this.word = w;
        this.nodes = {};
    }
}

class Trie {
    constructor(data) {
        this.root = new TrieNode(null);
        data.forEach((str) => {
            this.insert(this.root, str);
        });
    }
    insert(node, str, index = 0) {
        // 到最后一个字符
        if (index > str.length - 1) {
            return;
        }
        let word = str[index];
        let n = node.nodes[word];
        if (!n) {
            n = new TrieNode(word);
            node.nodes[word] = n;
        }
        this.insert(n, str, index + 1);
    }

    find(str, nodes = this.root.nodes, index = 0) {
        if(str.length === index){
            return true;
        }
        const word = str[index];
        const n = nodes[word];
        if (!n) {
            return false;
        }
        return this.find(str, n.nodes, index + 1);
    }
}

// https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/
// https://leetcode-cn.com/problems/map-sum-pairs/
```

## 完全二叉树
最后一层不满，而且有值得话，得是左节点，
给定一个数组表示的完全二叉树，
任意节点索引是i,
那么左子节点索引是 `2 * i + 1`, 右子节点是 `2 * i + 2` 
父节点是 `(i -1)/2`

**堆插入操作 Heap Insert  往上调整**
不停的调整，就是自己和父节点不停比较交换的过程。
这种新数字插入操作，时复杂度是 `lgn`

**堆调整操作 Heaptify 往下调整**
如果把大根堆的根去掉，再调整后返回一个大跟堆，
需要把最后一个节点复制一份作为根节点
然后 heapsize 减一，判断根节点和左右节点的值，如果小于某个节点值，交换，然后递归判断交换的那个节点，如果没有就没问题，因为本来是一个大根堆，大跟堆的左右节点也是大根堆。结束条件，无左右节点，或者此节点值大于左右节点的值。

如果改变节点i的值，如果小了，就往下调整，如果大了，就往上调整。

## 堆
### 大根堆和小根堆
是完全二叉树，且根节点是最大或者最小

### 堆排序
不停的执行堆插入操作，得到大跟堆，把根节点和最后一个值交换，保证后边的有序，然后再执行前边的再变成大根堆。。。
堆排序的额外空间复杂度是 `O(1)`
```javascript
var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量
function buildMaxHeap(arr) {   // 建立大顶堆
  len = arr.length;
  for (var i = Math.floor(len / 2); i >= 0; i--) {
    heapify(arr, i);
  }
}
function heapify(arr, i) {     // 堆调整
  var left = 2 * i + 1,
    right = 2 * i + 2,
    largest = i;
  if (left < len && arr[left] > arr[largest]) {
    largest = left;
  }
  if (right < len && arr[right] > arr[largest]) {
    largest = right;
  }
  if (largest != i) {
    swap(arr, i, largest);
    heapify(arr, largest);
  }
}
function swap(arr, i, j) {
  var temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}
function heapSort(arr) {
  buildMaxHeap(arr);
  for (var i = arr.length - 1; i > 0; i--) {
    swap(arr, 0, i);
    len--;
    heapify(arr, 0);
  }
  return arr;
}
```

### 堆排序扩展
对一个几乎有序的数组进行排序，几乎有序就是元素和排好的元素不会超过k
其实就是构建一个k个元素的小根堆，第一个就是最小的数，不停的调整，
比如k=6，取0-6索引的7个数，0放小跟堆的最小值，然后后移1位，1再放最小值，
不同的取值，不停的调整小根堆，复杂度就是O(n*lgk)
```java
PriorityQueue<Integer> heap = new PriorityQueue();
// 假定k小于数组长度
public void fn(int arr[], int k){
    int index = 0;
    for(; index <=k; index++){
        heap.add(arr[index]);
    }
    int i = 0;
    for(; index < arr.length; index++){
           heap.add(arr[index]);
           arr[i] = heap.poll();
    }
    while(!heap.isEmpty()){
        arr[i++] = heap.poll();
    }
}
```

### 优先级队列结构
就是堆，堆需要扩容的，扩容是成倍的扩容，
也是logn，如果需要频繁地从管理的数据中取出最小值，那么使用堆来操作会非常方便，就是优先级队列

```java
import java.util.PriorityQueue

PriorityQueue<Integer> heap = new PriorityQueue();
heap.add(21);
heap.add(2);
heap.add(3);
System.out.println(heap.poll());
System.out.println(heap.poll());
System.out.println(heap.poll());

```

### 比较器
比较器可以用在有序的数据结构，比如堆
```java
//Comp 为自定义的比较器
PriorityQueue<Integer> heap = new PriorityQueue(new Comp());
```

## 二叉搜索树

### 二叉搜索树，两个节点的公共祖先
挖掘出隐藏条件，公共祖先的节点值，大于其中一个值，小于其中一个值
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        TreeNode ancestor = root;
        while (true) {
            if (p.val < ancestor.val && q.val < ancestor.val) {
                ancestor = ancestor.left;
            } else if (p.val > ancestor.val && q.val > ancestor.val) {
                ancestor = ancestor.right;
            } else {
                break;
            }
        }
        return ancestor;
    }
}
``` 
### 验证数组是二叉搜索树的后续遍历结果
- 最后一个节点是根节点
- 小于根节点的值，在左树
- 找到大于根节点的第一个值，判断后边的值都大于根节点 
```javascript
function fn(arr, left, right) {
  if (left >= right) {
    return true;
  }
  let p = -1, nodeVal = arr[right];
  for (let i = 0; i < right; i++) {
    // 找第一个大于根节点的节点，就是右树的开始
    if (p < 0 && arr[i] > nodeVal) {
      p = i;
    }
    // 如果右树，有任意小于根节点的直接返回false
    if (p > -1 && i >= p && arr[i] < nodeVal) {
      return false;
    }
  }
  if (p > -1) {
    return fn(arr, left, p - 1) && fn(arr, p, right - 1);
  } else {
    return fn(arr, left, right - 1);
  }
}

var verifyPostorder = function (arr) {
  return fn(arr, 0, arr.length - 1);
};

```

### 二叉平衡搜索树
```java
// todo 
// https://blog.csdn.net/tanrui519521/article/details/80935348
// 二叉搜索树中第K小的元素 常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        // 中序遍历生成数值列表
        List<Integer> inorderList = new ArrayList<Integer>();
        inorder(root, inorderList);

        // 构造平衡二叉搜索树
        AVL avl = new AVL(inorderList);

        // 模拟1000次插入和删除操作
        int[] randomNums = new int[1000];
        Random random = new Random();
        for (int i = 0; i < 1000; ++i) {
            randomNums[i] = random.nextInt(10001);
            avl.insert(randomNums[i]);
        }
        shuffle(randomNums); // 列表乱序
        for (int i = 0; i < 1000; ++i) {
            avl.delete(randomNums[i]);
        }

        return avl.kthSmallest(k);
    }

    private void inorder(TreeNode node, List<Integer> inorderList) {
        if (node.left != null) {
            inorder(node.left, inorderList);
        }
        inorderList.add(node.val);
        if (node.right != null) {
            inorder(node.right, inorderList);
        }
    }

    private void shuffle(int[] arr) {
        Random random = new Random();
        int length = arr.length;
        for (int i = 0; i < length; i++) {
            int randIndex = random.nextInt(length);
            int temp = arr[i];
            arr[i] = arr[randIndex];
            arr[randIndex] = temp;
        }
    }
}

// 平衡二叉搜索树（AVL树）：允许重复值
class AVL {
    Node root;

    // 平衡二叉搜索树结点
    class Node {
        int val;
        Node parent;
        Node left;
        Node right;
        int size;
        int height;

        public Node(int val) {
            this(val, null);
        }

        public Node(int val, Node parent) {
            this(val, parent, null, null);
        }

        public Node(int val, Node parent, Node left, Node right) {
            this.val = val;
            this.parent = parent;
            this.left = left;
            this.right = right;
            this.height = 0; // 结点高度：以node为根节点的子树的高度（高度定义：叶结点的高度是0）
            this.size = 1; // 结点元素数：以node为根节点的子树的节点总数
        }
    }

    public AVL(List<Integer> vals) {
        if (vals != null) {
            this.root = build(vals, 0, vals.size() - 1, null);
        }
    }

    // 根据vals[l:r]构造平衡二叉搜索树 -> 返回根结点
    private Node build(List<Integer> vals, int l, int r, Node parent) {
        int m = (l + r) >> 1;
        Node node = new Node(vals.get(m), parent);
        if (l <= m - 1) {
            node.left = build(vals, l, m - 1, node);
        }
        if (m + 1 <= r) {
            node.right = build(vals, m + 1, r, node);
        }
        recompute(node);
        return node;
    }

    // 返回二叉搜索树中第k小的元素
    public int kthSmallest(int k) {
        Node node = root;
        while (node != null) {
            int left = getSize(node.left);
            if (left < k - 1) {
                node = node.right;
                k -= left + 1;
            } else if (left == k - 1) {
                break;
            } else {
                node = node.left;
            }
        }
        return node.val;
    }

    public void insert(int v) {
        if (root == null) {
            root = new Node(v);
        } else {
            // 计算新结点的添加位置
            Node node = subtreeSearch(root, v);
            boolean isAddLeft = v <= node.val; // 是否将新结点添加到node的左子结点
            if (node.val == v) { // 如果值为v的结点已存在
                if (node.left != null) { // 值为v的结点存在左子结点，则添加到其左子树的最右侧
                    node = subtreeLast(node.left);
                    isAddLeft = false;
                } else { // 值为v的结点不存在左子结点，则添加到其左子结点
                    isAddLeft = true;
                }
            }

            // 添加新结点
            Node leaf = new Node(v, node);
            if (isAddLeft) {
                node.left = leaf;
            } else {
                node.right = leaf;
            }

            rebalance(leaf);
        }
    }

    // 删除值为v的结点 -> 返回是否成功删除结点
    public boolean delete(int v) {
        if (root == null) {
            return false;
        }

        Node node = subtreeSearch(root, v);
        if (node.val != v) { // 没有找到需要删除的结点
            return false;
        }

        // 处理当前结点既有左子树也有右子树的情况
        // 若左子树比右子树高度低，则将当前结点替换为右子树最左侧的结点，并移除右子树最左侧的结点
        // 若右子树比左子树高度低，则将当前结点替换为左子树最右侧的结点，并移除左子树最右侧的结点
        if (node.left != null && node.right != null) {
            Node replacement = null;
            if (node.left.height <= node.right.height) {
                replacement = subtreeFirst(node.right);
            } else {
                replacement = subtreeLast(node.left);
            }
            node.val = replacement.val;
            node = replacement;
        }

        Node parent = node.parent;
        delete(node);
        rebalance(parent);
        return true;
    }

    // 删除结点p并用它的子结点代替它，结点p至多只能有1个子结点
    private void delete(Node node) {
        if (node.left != null && node.right != null) {
            return;
            // throw new Exception("Node has two children");
        }
        Node child = node.left != null ? node.left : node.right;
        if (child != null) {
            child.parent = node.parent;
        }
        if (node == root) {
            root = child;
        } else {
            Node parent = node.parent;
            if (node == parent.left) {
                parent.left = child;
            } else {
                parent.right = child;
            }
        }
        node.parent = node;
    }

    // 在以node为根结点的子树中搜索值为v的结点，如果没有值为v的结点，则返回值为v的结点应该在的位置的父结点
    private Node subtreeSearch(Node node, int v) {
        if (node.val < v && node.right != null) {
            return subtreeSearch(node.right, v);
        } else if (node.val > v && node.left != null) {
            return subtreeSearch(node.left, v);
        } else {
            return node;
        }
    }

    // 重新计算node结点的高度和元素数
    private void recompute(Node node) {
        node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));
        node.size = 1 + getSize(node.left) + getSize(node.right);
    }

    // 从node结点开始（含node结点）逐个向上重新平衡二叉树，并更新结点高度和元素数
    private void rebalance(Node node) {
        while (node != null) {
            int oldHeight = node.height, oldSize = node.size;
            if (!isBalanced(node)) {
                node = restructure(tallGrandchild(node));
                recompute(node.left);
                recompute(node.right);
            }
            recompute(node);
            if (node.height == oldHeight && node.size == oldSize) {
                node = null; // 如果结点高度和元素数都没有变化则不需要再继续向上调整
            } else {
                node = node.parent;
            }
        }
    }

    // 判断node结点是否平衡
    private boolean isBalanced(Node node) {
        return Math.abs(getHeight(node.left) - getHeight(node.right)) <= 1;
    }

    // 获取node结点更高的子树
    private Node tallChild(Node node) {
        if (getHeight(node.left) > getHeight(node.right)) {
            return node.left;
        } else {
            return node.right;
        }
    }

    // 获取node结点更高的子树中的更高的子树
    private Node tallGrandchild(Node node) {
        Node child = tallChild(node);
        return tallChild(child);
    }

    // 重新连接父结点和子结点（子结点允许为空）
    private static void relink(Node parent, Node child, boolean isLeft) {
        if (isLeft) {
            parent.left = child;
        } else {
            parent.right = child;
        }
        if (child != null) {
            child.parent = parent;
        }
    }

    // 旋转操作
    private void rotate(Node node) {
        Node parent = node.parent;
        Node grandparent = parent.parent;
        if (grandparent == null) {
            root = node;
            node.parent = null;
        } else {
            relink(grandparent, node, parent == grandparent.left);
        }

        if (node == parent.left) {
            relink(parent, node.right, true);
            relink(node, parent, false);
        } else {
            relink(parent, node.left, false);
            relink(node, parent, true);
        }
    }

    // trinode操作
    private Node restructure(Node node) {
        Node parent = node.parent;
        Node grandparent = parent.parent;

        if ((node == parent.right) == (parent == grandparent.right)) { // 处理需要一次旋转的情况
            rotate(parent);
            return parent;
        } else { // 处理需要两次旋转的情况：第1次旋转后即成为需要一次旋转的情况
            rotate(node);
            rotate(node);
            return node;
        }
    }

    // 返回以node为根结点的子树的第1个元素
    private static Node subtreeFirst(Node node) {
        while (node.left != null) {
            node = node.left;
        }
        return node;
    }

    // 返回以node为根结点的子树的最后1个元素
    private static Node subtreeLast(Node node) {
        while (node.right != null) {
            node = node.right;
        }
        return node;
    }

    // 获取以node为根结点的子树的高度
    private static int getHeight(Node node) {
        return node != null ? node.height : 0;
    }

    // 获取以node为根结点的子树的结点数
    private static int getSize(Node node) {
        return node != null ? node.size : 0;
    }
}
```
