# 树基本算法
```javascript
  let Node = function (num, left, right) {
    let node = Object.create(null);
    node.value = num;
    node.left = left === null ? null : Node(left, null, null);
    node.right = left === null ? null : Node(right, null, null);
    node.p = null;
    return node;
  }
```

## 完全二叉树
最后一层不满，而且有值得话，得是左节点，
给定一个数组表示的完全二叉树，
任意节点索引是i,
那么左子节点索引是 `2 * i + 1`, 右子节点是 `2 * i + 2` 
父节点是 `(i -1)/2`

## 树的遍历
```javascript
function walk(root) {
  if(root === null){
    return;
  }
  walk(root.left)
  walk(root.right)
}

```
根据遍历的方法，产生一个递归序，比如树`[1,2,3]`遍历的递归序结果是 `122213331`
前序遍历，就是进入就操作，中序遍历就是第二次再操作，后续是最后一次才操作
对应的结果是 `123`,`213`,`231`

## 树的层次遍历
```javascript
 function layerWalk(root){
      let q = [];
      let r = [];
      if(root){
        let currentLevel = 0;
        let currentLevelLastnode = root;
        let nextLevelLastnode = null;
        let q = [root];
        r[currentLevel] = []
        while(q.length){
          let node = q.shift();
          r[currentLevel].push(node.val)
          if(node.left){
            nextLevelLastnode = node.left;
            q.push(node.left)
          }
          if(node.right){
            nextLevelLastnode = node.right;
            q.push(node.right)
          }
          if(node === currentLevelLastnode){
            currentLevel++;
            r[currentLevel] = [];
            currentLevelLastnode = nextLevelLastnode;
            nextLevelLastnode = null;
          }
        }
      }
      return r;
    }


```

## 非递归遍历
```javascript
// 前序遍历
// 1. 根节点入栈
// 2. 出栈，打印值
// 3. 先右后左入栈
// 继续
function preOrderWalk(root) {
  let stack = [];
  stack.push(root);
  while (stack.length) {
    let node = stack.pop();
    // console.log(node.val);
    if (node.right) {
      stack.push(node.right);
    }
    if (node.left) {
      stack.push(node.left);
    }
  }
}

// 后序遍历，
// 比如 1 2 3 ，增加一个收集栈 stack2
// 前序遍历，栈的操作是，中右左，1入栈3入栈2入栈，打印结果就是 1 2 3 
// 如果是入栈的顺序是中左右，就是 前序遍历v2， 1入栈出栈再入栈stack2，然后2入栈，3入栈，然后3出栈2出栈放到stack2
// 前边的栈只操作，放到收集栈的结果，结果就是左右中，就是 后序遍历，就是 2 3 1
function postOrderWalk(root) {
  let stack = [];
  let s = [];
  stack.push(root);
  while (stack.length) {
    let node = stack.pop();
    s.push(node)
    if (node.left) {
      stack.push(node.left);
    }
    if (node.right) {
      stack.push(node.right);
    }
  }
  while (s.length) {
    let node = s.pop();
    console.log(node.val)
  }
}

// 中序遍历，非递归
// 1. 不停的把左树扔到栈
// 2, 出来就打印，如果有右树，重复
function inOrderWalk() {
  
}

```

### 练习1 完全二叉树的节点个数
```java
class Solution {
    public int countNodes(TreeNode root) {
        if(root == null){
           return 0;
        } 
        int left = countLevel(root.left);
        int right = countLevel(root.right);
        if(left == right){
            return countNodes(root.right) + (1<<left);
        }else{
            return countNodes(root.left) + (1<<right);
        }
    }
    private int countLevel(TreeNode root){
        int level = 0;
        while(root != null){
            level++;
            root = root.left;
        }
        return level;
    }
}

```
