# 归并排序和主公式
## 中间值
```c
求数组 left 和right的中间值
一般是  let mid = (left + right) / 2 
这种写法的问题，如果数组特别大，接近数字极限值，这样结果是负的
所以这么写 let mid = left + (right - left)/2 = left + ((right - left) >> 1 )
```

## 数组最大值
```java 
 // 时间复杂度是O(n) 等同 于一遍循环查找的
  function getMax(arr) {
    return fn(arr, 0, arr.length - 1)
  }

  function fn(arr, left, right) {
    if(left === right){
      return arr[left];
    }
    let mid = left + ((right  -left) >> 1)
    let max1 = fn(arr, left, mid)
    let max2 = fn(arr, mid + 1, right)
    return Math.max(max1, max2)
  }
```
## 主方法解递归式
必须子问题规模相同
归并排序，为什么比冒泡排序、选择排序效率高，因为上一次的结果被缓存为有序的部分数组了，而后者浪费了大量的比较。

### 题目1 求小和、逆序对
数组大小有关的，都可以用归并排序 
求给定数组 [1,4,2,3,5] 数组的小和

> 1左边没有比他小的是0，
>  4左边1一个1比他小，小和是1
>   2左边也是1 
>   3是 3 5是10 
>   所以结果是 15

```javascript
// 这个问题是要转换思路，从求小和问题，变成求大和问题，就是
  function smallSum(arr) {
    if(!arr || arr.length < 2){
      return 0;
    }
    return fn(arr,0, arr.length -1)
  }

  function fn(arr, left, right) {
    if(left === right){
      return 0;
    }
    let mid = left + ((right - left) >> 1 );
    return fn(arr, left, mid) + fn(arr, mid + 1, right) + merge(arr, left, mid, right)
  }

  function merge(arr, l, m, r) {
    let help = new Array(r - l + 1);
    let i = 0;
    let p1 = l;
    let p2 = m + 1;
    let res = 0;
    while(p1 <= m && p2 <= r)  {
      res+= arr[p1] < arr[p2] ? (r-p2 + 1) * arr[p1] : 0;
      help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
    }
    while(p1 <= m){
      help[i++] = arr[p1++]
    }
    while(p2 <= r){
      help[i++] = arr[p2++]
    }
    for(let i=0;i < help.length;i++){
      arr[l+i] = help[i];
    }
    return res;
  }
```
## 快速排序扩展
### 数组大于某个数的右边，其余左边
- 给一个数组、某个数字，小于某个数字的放在左边大于在后边
- 解法，就是假设数组前边有一个空的排序好的数组，后边如果找到小于目标值的，就扔到前边的结果去，然后边界值+1
```javascript
let arr = [1,6,2,3,4,5,8,9],num = 6;
function range(arr, num) {
  let i = 0, border = -1;
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] <= num) {
      [arr[i], arr[border + 1]] = [arr[border + 1], arr[i]];
      border++;
    }
  }
  return arr;
}
```
### 荷兰国旗问题，题目2扩展分为小等大3个区域

i表示左边界的指针，如果 arr[i] < num,
  i和左边界的下一个数交换，左边界扩展一个单位
  if arr[i] == num  (i++)
  if(arr[i] > num) 和右边界的前一个交换，右边界扩展一个单位  i不动
  当i和右边界接头，退出

### 由题目2引申出的快速排序
荷兰国旗问题 + 输入数据极端情况，是O(n2)，所以要随机化种子
  

