# 树算法
## 完全二叉树
最后一层不满，而且有值得话，得是左节点，
给定一个数组表示的完全二叉树，
任意节点索引是i,
那么左子节点索引是 `2 * i + 1`, 右子节点是 `2 * i + 2` 
父节点是 `(i -1)/2`

**堆插入操作 Heap Insert  往上调整**
不停的调整，就是自己和父节点不停比较交换的过程。
这种新数字插入操作，时复杂度是 `lgn`

**堆调整操作 Heaptify 往下调整**
如果把大根堆的根去掉，再调整后返回一个大跟堆，
需要把最后一个节点复制一份作为根节点
然后 heapsize 减一，判断根节点和左右节点的值，如果小于某个节点值，交换，然后递归判断交换的那个节点，如果没有就没问题，因为本来是一个大根堆，大跟堆的左右节点也是大根堆。结束条件，无左右节点，或者此节点值大于左右节点的值。

如果改变节点i的值，如果小了，就往下调整，如果大了，就往上调整。

## 大根堆和小根堆
是完全二叉树，且根节点是最大或者最小

## 堆排序
不停的执行堆插入操作，得到大跟堆，把根节点和最后一个值交换，保证后边的有序，然后再执行前边的再变成大根堆。。。
堆排序的额外空间复杂度是 `O(1)`
```javascript
var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量
function buildMaxHeap(arr) {   // 建立大顶堆
  len = arr.length;
  for (var i = Math.floor(len / 2); i >= 0; i--) {
    heapify(arr, i);
  }
}
function heapify(arr, i) {     // 堆调整
  var left = 2 * i + 1,
    right = 2 * i + 2,
    largest = i;
  if (left < len && arr[left] > arr[largest]) {
    largest = left;
  }
  if (right < len && arr[right] > arr[largest]) {
    largest = right;
  }
  if (largest != i) {
    swap(arr, i, largest);
    heapify(arr, largest);
  }
}
function swap(arr, i, j) {
  var temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}
function heapSort(arr) {
  buildMaxHeap(arr);
  for (var i = arr.length - 1; i > 0; i--) {
    swap(arr, 0, i);
    len--;
    heapify(arr, 0);
  }
  return arr;
}
```


## 优先级队列结构
就是堆


## 二叉搜索树

### 二叉搜索树，两个节点的公共祖先
挖掘出隐藏条件，公共祖先的节点值，大于其中一个值，小于其中一个值
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        TreeNode ancestor = root;
        while (true) {
            if (p.val < ancestor.val && q.val < ancestor.val) {
                ancestor = ancestor.left;
            } else if (p.val > ancestor.val && q.val > ancestor.val) {
                ancestor = ancestor.right;
            } else {
                break;
            }
        }
        return ancestor;
    }
}
``` 
### 验证数组是二叉搜索树的后续遍历结果
- 最后一个节点是根节点
- 小于根节点的值，在左树
- 找到大于根节点的第一个值，判断后边的值都大于根节点 
```java
function fn(arr, left, right) {
  if (left >= right) {
    return true;
  }
  let p = -1, nodeVal = arr[right];
  for (let i = 0; i < right; i++) {
    // 找第一个大于根节点的节点，就是右树的开始
    if (p < 0 && arr[i] > nodeVal) {
      p = i;
    }
    // 如果右树，有任意小于根节点的直接返回false
    if (p > -1 && i >= p && arr[i] < nodeVal) {
      return false;
    }
  }
  if (p > -1) {
    return fn(arr, left, p - 1) && fn(arr, p, right - 1);
  } else {
    return fn(arr, left, right - 1);
  }
}

var verifyPostorder = function (arr) {
  return fn(arr, 0, arr.length - 1);
};

```