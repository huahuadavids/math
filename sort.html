<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    <script type="text">
      // https://leetcode-cn.com/problems/complex-number-multiplication/
      // https://leetcode-cn.com/problems/insert-interval/
      let intervals = [
          [1, 2],
          [3, 5],
          [6, 7],
          [8, 10],
          [12, 16],
        ],
        newInterval = [4, 8];
      let out = [
        [1, 2],
        [3, 10],
        [12, 16],
      ];

      // 1. 输入区间是不重叠的
      var insert = function (arr, item) {
        let prev = null;
        let resultsult = [];
        // 代表 item是否被合并了
        let merged = false;

        const [left, right] = item;
        for (let i = 0; i < arr.length; i++) {
          const tmpent = arr[i];
          const [c1, c2] = tmpent;
          // 判断 item 是否在 tmpent 区间内
          if (c1 <= left && c2 >= right) {
            return arr;
          }
          if (prev) {
            // 判断
          } else {
            prev = tmpent;
            resultsult.push(tmpent);
          }
        }
        return resultsult;
      };
    </script>

    <script type="text">
      function TrieNode() {
        const res = Object.create(null);
        const nodes = Object.create(null);
        res.nodes = nodes;
        return res;
      }

      class Trie {
        constructor(data) {
          this.root = TrieNode();
          data.forEach((str) => {
            this.insert(this.root, str);
          });
        }

        insert(node = this.root, str, index = 0) {
          // 到最后一个字符
          if (index > str.length - 1) {
            return;
          }
          let word = str[index];
          let n = node.nodes[word];
          if (!n) {
            n = TrieNode();
            node.nodes[word] = n;
          }
          this.insert(n, str, index + 1);
        }

        find(str, nodes = this.root.nodes, index = 0) {
          if (str.length === index) {
            return true;
          }
          const word = str[index];
          const n = nodes[word];
          if (!n) {
            return false;
          }
          return this.find(str, n.nodes, index + 1);
        }
      }

      console.log(new Trie(["h", "ho"]));

      // 前缀树专题
      // https://leetcode-cn.com/problems/word-break/
      // https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/
      // https://leetcode-cn.com/problems/map-sum-pairs/
      // https://leetcode-cn.com/problems/lexicographical-numbers/
      // https://leetcode-cn.com/problems/top-k-frequent-words/
      // https://leetcode-cn.com/problems/camelcase-matching/
    </script>

    <script>
      let s = "applepenapple",
        wordDict = ["apple", "pen"];

      s = "111catsandog";
      wordDict = ["cats", "dog", "sand", "and", "cat"];

      function fn(arr, s) {}

      var wordBreak = function (s, wordDict) {
        let r = false;
        for (let i = 0; i < wordDict.length; i++) {
          let str = wordDict[i];
          let index = s.indexOf(str);
          if (index > -1) {
            let str1 = s.slice(index, index + str.length);
            r = fn(wordDict, str1);
            if (r) {
              return r;
            }
          }
        }
        return r;
      };
    </script>

    <script>
      let Node = function (num, left, right) {
        let node = Object.create(null);
        node.value = num;
        node.left = left === null ? null : Node(left, null, null);
        node.right = left === null ? null : Node(right, null, null);
        return node;
      };

      const left = Node(9, 3, 12);
      const right = Node(23, 17, 28);
      const root = Node(15, null, null);
      left.left.right = Node(8, null, null);
      root.left = left;
      root.right = right;

      function deleteNode(root, value) {
        if (root) {
          if (root.value === value) {
          }
        }
        return root;
      }

      function toMap(str) {
        let map = {};
        for (let i = 0; i < str.length; i++) {
          let char = str[i];
          if (map[char]) {
            map[char]++;
          } else {
            map[char] = 1;
          }
        }
        return map;
      }

      function ListNode(val, next) {
        const node = Object.create(null);
        node.val = val === undefined ? 0 : val;
        node.next = next === undefined ? null : next;
        return node;
      }
    </script>
    <script>
      let arr1 = [1, 2, 3, 1];
      let arr2 = [2, 2, 3, 1];
      // todo
      // https://leetcode-cn.com/problems/poor-pigs/
      // https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/
    </script>
    <script>
      {
        let reg = /[abcdedfg - [a - c]]/g;
        let str = "uyy";
        // 匹配1234
        console.log(str.match(reg));
      }
    </script>
    <script>
      let arr = [1, 0, 1, 1, 0, 1, 1];

      var findMaxLength = function (nums) {
        let sums = [];
        let total = 0;
        nums.forEach((n) => {
          total += n;
          sums.push(total);
        });
        console.log(sums);
      };
      findMaxLength(arr);
    </script>

    <script>
      // https://leetcode-cn.com/problems/reverse-linked-list-ii/
      var reverseList = function (head) {
        let result = null;
        let current = head;
        while (current) {
          const nextNodes = current.next;
          current.next = result;
          result = current;
          current = nextNodes;
        }
        return result;
      };
      var reverseList2 = function (head, left, right) {};
    </script>
  </body>
</html>
