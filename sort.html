<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
</head>

<body>
  <script>
    // https://leetcode-cn.com/problems/complex-number-multiplication/
    // https://leetcode-cn.com/problems/insert-interval/
    let intervals = [
      [1, 2],
      [3, 5],
      [6, 7],
      [8, 10],
      [12, 16],
    ],
      newInterval = [4, 8];
    let out = [
      [1, 2],
      [3, 10],
      [12, 16],
    ];

    // 1. 输入区间是不重叠的
    var insert = function (arr, item) {
      let prev = null;
      let resultsult = [];
      // 代表 item是否被合并了
      let merged = false;

      const [left, right] = item;
      for (let i = 0; i < arr.length; i++) {
        const current = arr[i];
        const [c1, c2] = current;
        // 判断 item 是否在 current 区间内
        if (c1 <= left && c2 >= right) {
          return arr;
        }
        if (prev) {
          // 判断
        } else {
          prev = current;
          resultsult.push(current);
        }
      }
      return resultsult;
    };
  </script>

  <script>
    function TrieNode() {
      const res = Object.create(null);
      const nodes = Object.create(null);
      res.nodes = nodes;
      return res;
    }

    class Trie {
      constructor(data) {
        this.root = TrieNode();
        data.forEach((str) => {
          this.insert(this.root, str);
        });
      }

      insert(node = this.root, str, index = 0) {
        // 到最后一个字符
        if (index > str.length - 1) {
          return;
        }
        let word = str[index];
        let n = node.nodes[word];
        if (!n) {
          n = TrieNode();
          node.nodes[word] = n;
        }
        this.insert(n, str, index + 1);
      }

      find(str, nodes = this.root.nodes, index = 0) {
        if (str.length === index) {
          return true;
        }
        const word = str[index];
        const n = nodes[word];
        if (!n) {
          return false;
        }
        return this.find(str, n.nodes, index + 1);
      }
    }

    console.log(new Trie(["h", "ho"]));

  // 前缀树专题
  // https://leetcode-cn.com/problems/word-break/
  // https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/
  // https://leetcode-cn.com/problems/map-sum-pairs/
  // https://leetcode-cn.com/problems/lexicographical-numbers/
  // https://leetcode-cn.com/problems/top-k-frequent-words/
  // https://leetcode-cn.com/problems/camelcase-matching/
  </script>

  <script>
    let s = "applepenapple",
      wordDict = ["apple", "pen"];

    s = "111catsandog";
    wordDict = ["cats", "dog", "sand", "and", "cat"];

    function fn(arr, s) {
    }

    var wordBreak = function (s, wordDict) {
      let r = false;
      for (let i = 0; i < wordDict.length; i++) {
        let str = wordDict[i];
        let index = s.indexOf(str);
        if (index > -1) {
          let str1 = s.slice(index, index + str.length);
          r = fn(wordDict, str1);
          if (r) {
            return r;
          }
        }
      }
      return r;
    };
  </script>

  <script>
    let Node = function (num, left, right) {
      let node = Object.create(null);
      node.value = num;
      node.left = left === null ? null : Node(left, null, null);
      node.right = left === null ? null : Node(right, null, null);
      return node;
    }

    const left = Node(9, 3, 12);
    const right = Node(23, 17, 28);
    const root = Node(15, null, null)
    left.left.right = Node(8, null, null)
    root.left = left;
    root.right = right;


    function deleteNode(root, value) {
      if (root) {
        if (root.value === value) {

        }
      }
      return root;
    }
  </script>
  <script>
    // https://leetcode-cn.com/problems/rotate-list/
    let head = { "val": 1, "next": { "val": 2, "next": { "val": 3, "next": { "val": 4, "next": { "val": 5, "next": null } } } } }

    var rotateRight = function (head, k) {
      let len = 0;
      let tmp = head;
      while (tmp) {
        len++
        tmp = tmp.next;
      }
      let n = k % len;
      if(n === 0){
        return head;
      }
      let node;
      let len1 = 0;
      tmp = head;
      while (tmp) {
        len1++;
        if(len1 === len -k){
          node = tmp.next;
          break;
        }
        tmp = tmp.next;
      }
      console.log(head)
      console.log(node)
      
    };
    rotateRight(head, 2)
  </script>
</body>

</html>