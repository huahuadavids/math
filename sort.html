<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // https://leetcode-cn.com/problems/complex-number-multiplication/
      // https://leetcode-cn.com/problems/insert-interval/
      let intervals = [
          [1, 2],
          [3, 5],
          [6, 7],
          [8, 10],
          [12, 16],
        ],
        newInterval = [4, 8];
      let out = [
        [1, 2],
        [3, 10],
        [12, 16],
      ];

      // 1. 输入区间是不重叠的
      var insert = function (arr, item) {
        let prev = null;
        let resultsult = [];
        // 代表 item是否被合并了
        let merged = false;

        const [left, right] = item;
        for (let i = 0; i < arr.length; i++) {
          const current = arr[i];
          const [c1, c2] = current;
          // 判断 item 是否在 current 区间内
          if (c1 <= left && c2 >= right) {
            return arr;
          }
          if (prev) {
            // 判断
          } else {
            prev = current;
            resultsult.push(current);
          }
        }
        return resultsult;
      };
    </script>

    <script>
      function TrieNode() {
        const res = Object.create(null);
        const nodes = Object.create(null);
        res.nodes = nodes;
        return res;
      }

      class Trie {
        constructor(data) {
          this.root = TrieNode();
          data.forEach((str) => {
            this.insert(this.root, str);
          });
        }

        insert(node = this.root, str, index = 0) {
          // 到最后一个字符
          if (index > str.length - 1) {
            return;
          }
          let word = str[index];
          let n = node.nodes[word];
          if (!n) {
            n = TrieNode();
            node.nodes[word] = n;
          }
          this.insert(n, str, index + 1);
        }

        find(str, nodes = this.root.nodes, index = 0) {
          if (str.length === index) {
            return true;
          }
          const word = str[index];
          const n = nodes[word];
          if (!n) {
            return false;
          }
          return this.find(str, n.nodes, index + 1);
        }
      }

      console.log(new Trie(["h", "ho"]));

      // 前缀树专题
      // https://leetcode-cn.com/problems/word-break/
      // https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/
      // https://leetcode-cn.com/problems/map-sum-pairs/
      // https://leetcode-cn.com/problems/lexicographical-numbers/
      // https://leetcode-cn.com/problems/top-k-frequent-words/
      // https://leetcode-cn.com/problems/camelcase-matching/
    </script>

    <script>
      let s = "applepenapple",
        wordDict = ["apple", "pen"];

      s = "111catsandog";
      wordDict = ["cats", "dog", "sand", "and", "cat"];

      function fn(arr, s) {}

      var wordBreak = function (s, wordDict) {
        let r = false;
        for (let i = 0; i < wordDict.length; i++) {
          let str = wordDict[i];
          let index = s.indexOf(str);
          if (index > -1) {
            let str1 = s.slice(index, index + str.length);
            r = fn(wordDict, str1);
            if (r) {
              return r;
            }
          }
        }
        return r;
      };
    </script>

    <script>
      {
        const nums = [1, 7, 3, 6, 5, 6];
        var pivotIndex = function (nums) {
          let sums = {}, total = 0;
          let len = nums.length;
          let index = -1;
          sums[-1] = 0;
          sums[len] = 0;
          for (let i = 0; i < len; i++) {
            let t = total + nums[i];
            sums[i] = t;
            total = t;
          }
          for (let a = 0; a < len; a++) {
            let left = sums[a - 1];
            let right = total - sums[a];
            if (left === right) {
              index = a;
              break;
            }
          }
          return index;
        };

        console.log(pivotIndex([1, -1, 2]));
      }
    </script>
  </body>
</html>
